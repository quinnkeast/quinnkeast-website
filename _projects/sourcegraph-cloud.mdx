---
title: "Here, there, and back again: Sourcegraph Cloud"
subtitle: "The story of building, launching, and pivoting Sourcegraph’s Cloud product."
hero: "Sourcegraph example case study"
client: "Sourcegraph"
role: "Staff Product Designer"
period: "2022"
published: true
restricted: true
group: "sourcegraph"
size: "extra large"
ogImage:
  url: "/assets/blog/hello-world/cover.jpg"
thumbnail:
  url: "/assets/projects/ux-team.jpg"
---

Sourcegraph found its initial product-market fit by focusing on self-hosted deployments for Enterprise customers. This was a critical strategic decision, because we were asking companies to trust us with their most crucial asset: their private code.

But we also knew that this was limiting to our ongoing growth: many customers had no interest in self-hosting their own Sourcegraph instance, and wanted to use Sourcegraph as a cloud-based SaaS product.

This was one of the largest, longest-running efforts I worked on at Sourcegraph, wearing all kinds of hats, ultimately generating new projects that delivered value to all of Sourcegraph's customers.

Big assumption to validate: that customers will trust us with their private code in a Cloud environment.

Constraint set out from the beginning: we would validate this using Sourcegraph.com, which was the largest deployment of Sourcegraph in the world, with almost a million open source repositories indexed for search. The easiest way to iteratively validate this assumption was to build on top of Sourcegraph.com. We would also avoid creating a separate, standalone "Cloud" codebase. We knew we had some customers (including some of the top FAANG customers) that wanted their self-hosted instances to be multitenant. Building this out using Sourcegraph.com would effectively be bringing the same multitenant functionality to all self-hosted instances.

This presented a big challenge: everything about Sourcegraph's product was built on the assumption that Sourcegraph is a self-hosted, single-tenant product.

- All code on the instance belongs to the same organization.
- There is a person or team who can set up, orchestrate, and administrate Sourcegraph on the organization’s own stack and network.
- The instance admin will connect Sourcegraph with code hosts, and choose which repositories to add to Sourcegraph and make sure they sync properly.
- Running a global search on Sourcegraph will search across only your company’s repositories.
- All users on the Sourcegraph instance belong to the same company.
- A URL to a search result copied and pasted to someone else will “just work,” because everyone has access to the same code.
- There’s a high-touch, multi-stage sales process tailored for each customer.

The extent of this list of assumptions gave us an idea of just how big this challenge was, especially when we knew we wanted to keep one Sourcegraph—we didn’t want to split out into separate “Cloud” and “Self-hosted” products.

## Big vision, incremental action

We needed to strike the balance between the long-term of what Sourcegraph Cloud would become and the concrete steps that would get us there. Our approach was to orient around the problems, identify the foundations, and to be really thoughtful about what we needed when.

## Orienting around problems

Instead of orienting around action items or tactical steps, we oriented our efforts around problems that, when solved, would represent the “minimum lovable product” at each iteration.

At the highest level, these problems looked something like:

Sourcegraph Cloud is the easiest way for organizations to get started with Sourcegraph.
└── Small-to-medium organizations can search across their code together on Sourcegraph Cloud.
└── Individual users can search across their private code on Sourcegraph Cloud.
└── Sourcegraph team members can search across their private code on Sourcegraph Cloud.
└── Individual users can search across their public code on Sourcegraph Cloud.

Each problem was inherently cross-disciplinary and revealed a set of sub-problems we’d have to solve.

And each problem we solved would support each incremental step forward, all in a low-risk, high-confidence way that would help us to build momentum rather than rehashing the same problems again and again.

## Identify foundations

Once we had a roadmap of problems to solve, we took time to identify what we considered the “foundations”—those decisions that would influence all other decisions and ultimately accelerate future efforts, even if we didn’t act on them right away. Without identifying these foundations, we risked working ourselves into a corner by solving each problem in isolation, rather than as an incremental step within a bigger context.

For us, these foundations turned out to be mostly conceptual: what does it mean to “add code?” What about “connecting with code hosts?” How might that be the same, but different, for an individual user versus an organization? How does code visibility work? What’s the difference between what we’re doing here, and multitenancy? What decisions do we make now that will open up a future path to multitenancy?

We captured these decisions in async artifacts like an exploration of how multitenancy affects existing assumptions around roles and permissions (https://docs.google.com/document/d/1Xh2_UYQ-kcHcNAXwCSdj9SXOgat8POd3/edit#), and an information architecture summary (https://docs.google.com/document/d/1qHigYYB440SfqCfj-Gze38_IJLDY791J/edit#heading=h.gjdgxs). Async artifacts like these are a core part of how we work asynchronously at Sourcegraph. They make it easy to share and provide thoughtful, considered feedback, and to revisit and build on our shared understanding of these foundations.

## You ain’t gonna need it (yet)

Having both a clear roadmap of problems and a good idea of the foundations helped us to keep moving forward without feeling like we needed to solve every problem all at once. A big part of this meant constantly revisiting what we needed to do now, and what could be done later.

We know we’ll need a strong invitation flow for organizations (https://docs.google.com/document/d/1DqJWHmVHA6EpyKNAh0h-WNdsOprN8t-xTQbQ4CH8Z3I/edit). The way we connect with code hosts can keep improving. And we know we’ll eventually need things like self-service payments and subscription management. But we ain’t gonna need it yet.

After launching private code for individual users on Cloud, we did a collaborative story-mapping workshop to break out what we knew we’d need to do into a series of iterations that represented a fully functional, lovable product outcome. (https://miro.com/app/board/o9J_l2ceJwU=/?invite_link_id=556797444102)

- Generated project: search contexts
- Previous data showed that users who search code they care about (typically _their_ code) are more likely to have early success with onboarding and understanding the product value
- Problem of searching _their code_ among the nearly 2.2m repos on Cloud
  This led to proposing and building search contexts, an entirely new product feature, to solve this problem.
- See how this unfolded in search contexts project.

First iteration

- individual users can add their public code
- "what does it mean to add _my_ code to sourcegraph.com"
- separate team working on search contexts

Second iteration

- individual users can add their private code
- requires code host connections (and login connections)
- requires permissions handling (in line with agreed system)

Third iteration

- Handling system state
- Generated project: system status notifications

Fourth iteration

- Organizations can add private and public code and organization members can search across that code
- Code host connection challenge

Early access launch for organizations

- Generated project: helpful friction

Launch for commercial organizations

- achieved zero to one
- subsequently more than 100% outperformed target customers for the quarter

The pivot

- While we were working on multitenant cloud, we were also exploring "managed instances" – a way of deploying Sourcegraph where we set up and managed the instance ourselves. Essentially, a type of cloud product. This didn't scale effectively, because it was hands-on, but there was customer appetite for it.
- We had demonstrated through the combination of the commercial launch of multitenant cloud and the managed instances that our assumption was correct: we'd reached the point of being trusted with customer's private code in the cloud.
- The triad/quartet myself, the PM, the EM, and a staff engineer frequently revisited our goals and objectives with Cloud. In early 2022, we decided to challenge continuing with multitenant cloud. while we had paying customers and were growing, we felt that the numbers and priorities didn't make sense. the cost and complexity of continuing to build out multitenant cloud massively outstripped the potential revenue and reduced complexity of instead pivoting to single-tenant cloud.
- This was a decision we felt needed to be owned by the VP and director level, because it had significant impact on roadmap planning and organizational structure. I created the initial RFC together with the PM: https://docs.google.com/document/d/1X1IwuLm-jgB8XU81irnrahUPQlEQjWQY/edit
- ultimately, this proposal was accepted and the company executed the pivot. single-tenant sourcegraph cloud is now the default deployment option for new customers, and many of our existing self-hosted customers are migrating to cloud.
